"use client";

import {
  createContext,
  useContext,
  useState,
  useCallback,
  ReactNode,
  useEffect,
  useRef,
} from "react";
import { DataPoint } from "@/types/technical";
import axios from "axios";

const debug = {
  log: (...args: any[]) => {
    console.log("[OHLCV]", ...args);
  },
  error: (...args: any[]) => {
    console.error("[OHLCV Error]", ...args);
  }
};

interface PairData {
  pair: string;
  data: DataPoint[];
  currentIndex: number;
  countdown: number;
  lastUpdated: number;
}

interface OhlcvContextType {
  pairsData: Record<string, PairData>;
  isLoading: boolean;
  error: string | null;
  timeframe: string;
  setTimeframe: (timeframe: string) => void;
}

const MAJOR_PAIRS = ["EURUSD", "GBPUSD", "USDJPY", "USDCAD"];
const DEFAULT_TIMEFRAME = "1";

const OhlcvContext = createContext<OhlcvContextType | null>(null);

export function OhlcvProvider({ children }: { children: ReactNode }) {
  const isInitialized = useRef(false);
  const timerRef = useRef<NodeJS.Timeout | null>(null);

  const [pairsData, setPairsData] = useState<Record<string, PairData>>({});
  const [isLoading, setIsLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);
  const [timeframe, setTimeframe] = useState(DEFAULT_TIMEFRAME);

  const fetchPairData = useCallback(async (pair: string) => {
    debug.log(`Fetching data for ${pair}`);
    try {
      const response = await axios.get(`/api/forex-ohlcv/${pair}/${timeframe}`);
      debug.log(`Received data for ${pair}:`, response.data);
      
      if (!response.data?.data) {
        throw new Error('Invalid data structure received');
      }

      return {
        pair,
        data: response.data.data,
        currentIndex: 0,
        countdown: parseInt(timeframe) * 60,
        lastUpdated: Date.now(),
      };
    } catch (err) {
      debug.error(`Failed to fetch data for ${pair}:`, err);
      setError(`Failed to fetch data for ${pair}`);
      return null;
    }
  }, [timeframe]);

  const updateAllPairs = useCallback(async () => {
    debug.log('Updating all pairs...');
    const results = await Promise.all(MAJOR_PAIRS.map(pair => fetchPairData(pair)));
    
    setPairsData(prev => {
      const updated = { ...prev };
      results.forEach(result => {
        if (result) {
          const currentData = updated[result.pair];
          updated[result.pair] = {
            ...result,
            currentIndex: currentData?.currentIndex || 0,
            countdown: currentData?.countdown || parseInt(timeframe) * 60,
          };
        }
      });
      debug.log('Updated pairs data:', updated);
      return updated;
    });
  }, [fetchPairData, timeframe]);

  // Initial data fetch
  useEffect(() => {
    const initialize = async () => {
      if (!isInitialized.current) {
        debug.log('Initializing data...');
        await updateAllPairs();
        isInitialized.current = true;
        setIsLoading(false);
        debug.log('Initialization complete');
      }
    };

    initialize();
  }, [updateAllPairs]);

  // Timer setup
  useEffect(() => {
    if (!isInitialized.current) return;
    debug.log('Setting up timer');

    if (timerRef.current) {
      clearInterval(timerRef.current);
    }

    const timer = setInterval(() => {
      setPairsData(prev => {
        const updated = { ...prev };
        let needsUpdate = false;

        Object.keys(updated).forEach(pair => {
          const pairData = updated[pair];
          
          // Update countdown
          if (pairData.countdown > 0) {
            pairData.countdown -= 1;
            
            if (pairData.countdown % 10 === 0) {
              debug.log(`${pair}: ${pairData.countdown}s remaining`);
            }
          }

          // Check if we need to move to next data point
          if (pairData.countdown <= 0) {
            if (pairData.currentIndex < pairData.data.length - 1) {
              pairData.currentIndex += 1;
              pairData.countdown = parseInt(timeframe) * 60;
              debug.log(`${pair}: Moving to index ${pairData.currentIndex}`);
            } else {
              needsUpdate = true;
              pairData.currentIndex = 0;
              pairData.countdown = parseInt(timeframe) * 60;
              debug.log(`${pair}: Reached end, resetting`);
            }
          }
        });

        // If any pair needs new data, trigger update
        if (needsUpdate) {
          updateAllPairs();
        }

        return updated;
      });
    }, 1000);

    timerRef.current = timer;

    return () => {
      if (timerRef.current) {
        clearInterval(timerRef.current);
        debug.log('Timer cleaned up');
      }
    };
  }, [timeframe, updateAllPairs]);

  // Timeframe change handler
  useEffect(() => {
    if (isInitialized.current) {
      debug.log('Timeframe changed, updating data...');
      setIsLoading(true);
      updateAllPairs().finally(() => setIsLoading(false));
    }
  }, [timeframe, updateAllPairs]);

  if (!isInitialized.current && isLoading) {
    return <div>Loading OHLCV data...</div>;
  }

  return (
    <OhlcvContext.Provider
      value={{
        pairsData,
        isLoading,
        error,
        timeframe,
        setTimeframe,
      }}
    >
      {children}
    </OhlcvContext.Provider>
  );
}

export function useOhlcv() {
  const context = useContext(OhlcvContext);
  if (!context) {
    throw new Error("useOhlcv must be used within an OhlcvProvider");
  }
  return context;
}